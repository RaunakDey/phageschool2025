{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#quantitative-phagebacteria-dynamics-across-scales","title":"Quantitative Phage\u2013Bacteria Dynamics Across Scales","text":"<p>\ud83d\udccd June 23\u201327, 2025 \ud83d\udccd University of Maryland, College Park</p>"},{"location":"#scientific-committee-chair","title":"\ud83e\udde0 Scientific Committee Chair","text":"<ul> <li>Prof. Joshua Weitz (UMD)</li> <li>Dr. Marian Dominguez-Mirazo (UMD)</li> </ul>"},{"location":"#webpage-maintained-by","title":"\ud83e\uddea Webpage maintained by","text":"<p>Raunak Dey (UMD)</p> <p>Phage transform the fate of cells, populations, and ecosystems. Building on the interdisciplinary QLife workshops in Paris (2022 &amp; 2024), this summer school brings together researchers integrating models, experiments, and field data to explore the rich dynamics of phage\u2013bacteria interactions across biological scales.</p>"},{"location":"#objectives","title":"\ud83c\udfaf Objectives","text":"<p>Participants will: - Learn fundamental and cutting-edge methods in phage\u2013bacteria modeling - Explore mechanisms in spatial dynamics, phage therapy, evolution, and ecosystem functioning - Work with real data through computational labs and problem-solving exercises - Bridge models with empirical data using Python or R</p>"},{"location":"#daily-schedule-highlights","title":"\ud83d\udcc5 Daily Schedule Highlights","text":"<ul> <li>\u2600\ufe0f Morning \u2014 Lectures by leading experts</li> <li>\ud83d\udda5\ufe0f Afternoon \u2014 Hands-on computational labs</li> <li>\ud83c\udf19 Evening \u2014 Plenary talks or poster sessions</li> </ul>"},{"location":"#lecturers-speakers","title":"\ud83d\udc69\u200d\ud83c\udfeb Lecturers &amp; Speakers","text":"<ul> <li>Stephen Beckett (UMD)  </li> <li>Alita Burmeister (UW-Milwaukee)  </li> <li>Waqas Chaudhry (Tolka AI)  </li> <li>Tapan Goel (UMD)  </li> <li>Ido Golding (UIUC)  </li> <li>Jacopo Marchi (UMD)  </li> <li>Justin Meyer (UC San Diego)  </li> <li>Namiko Mitarai (Niels Bohr Institute)  </li> <li>Daniel Muratore (Santa Fe Institute)  </li> <li>Carey Nadell (Dartmouth College)  </li> <li>Sarah Preheim (JHU)  </li> <li>Paul Turner (Yale University)  </li> <li>Joshua Weitz (UMD)  </li> </ul>"},{"location":"#eligibility","title":"\u2705 Eligibility","text":"<ul> <li>Open to MS, PhD, and postdoc-level scientists</li> <li>Background in life sciences, physics, engineering, computer science, or mathematics</li> <li>Familiarity with Unix/Linux and proficiency in Python or R required  </li> <li>No registration fee for accepted participants</li> </ul>"},{"location":"#travel-application","title":"\ud83e\uddf3 Travel &amp; Application","text":"<ul> <li>Travel awards available  </li> <li>Applications must include:</li> <li>CV</li> <li>Motivation letter</li> <li>Letter of support</li> </ul> <p>\ud83d\udd17 Apply here \ud83d\udd52 Deadline: March 21, 2025</p>"},{"location":"#hosted-by","title":"\ud83e\uddec Hosted By:","text":"<ul> <li>BRIN Mathematics Research Center  </li> <li>College of Computer, Mathematical, and Natural Sciences  </li> <li>Institute for Health Computing</li> </ul> <p>\u201cIntegrating computational methods and models into phage-bacteria research practice, across scales.\u201d</p>"},{"location":"day1_eco_evo_principles/python_exercises_day1/","title":"Python - Exercises","text":"<p>Starting with the SV model, initiate an \u2018inoculation\u2019, adding $S0 = 10^4 $cell/mL of microbe, and then letting the population reach its equilibrium after approximately 24 h.</p> <p>Question: What population density does it reach? Is it what you expect? Compare your numerical simulation of S at the end of the simulation with the value of the equilibrium that you found analytically. Numerically, create a function describing the SV model and integrate it using python.</p> In\u00a0[1]: Copied! <pre># SV model function\ndef SV_ode(y,t,pars):\n    \"\"\"\n    returns the rate of change of host and virus in the standard SV model\n    \"\"\"\n    # initialization\n    dydt=np.zeros(2)\n    S = y[0]\n    V = y[1]\n    # Parameters\n    phi = pars[\"phi\"]\n    m = pars[\"m\"]\n    d = pars[\"d\"]\n    b = pars[\"b\"]\n    K = pars[\"K\"]\n    beta = pars[\"beta\"]\n    # system of ODEs\n    dydt[0] = b*S*(1-S/K) - phi*S*V - d*S\n    dydt[1] = beta*phi*S*V - phi*S*V - m*V\n    return dydt\n</pre> # SV model function def SV_ode(y,t,pars):     \"\"\"     returns the rate of change of host and virus in the standard SV model     \"\"\"     # initialization     dydt=np.zeros(2)     S = y[0]     V = y[1]     # Parameters     phi = pars[\"phi\"]     m = pars[\"m\"]     d = pars[\"d\"]     b = pars[\"b\"]     K = pars[\"K\"]     beta = pars[\"beta\"]     # system of ODEs     dydt[0] = b*S*(1-S/K) - phi*S*V - d*S     dydt[1] = beta*phi*S*V - phi*S*V - m*V     return dydt In\u00a0[2]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import integrate\n\n# Numerical time\nt0 = 0 # Initial time\ntf = 24 # Final time\nT = np.linspace(t0,tf) # time steps to report\n# Initial population size\ny0 = np.zeros(2)\ny0[0] = 1E4;\n# parameters\npars={}\npars[\"phi\"] = 6.7E-10\npars[\"m\"] = 1/24\npars[\"d\"] = 1/4\npars[\"b\"] = 0.95\npars[\"K\"] = 7.5E7\npars[\"beta\"] = 50\n\ndy = integrate.odeint(SV_ode,y0,T,args=(pars,))\nS = dy[:,0]\n\n# Find the equilibrium value numerically:\n\nSeq_num = S[-1]\n# plot\nplt.plot(T,S,'k', label=\"$S(t)$\")\nplt.scatter(T[-1],Seq_num,color='red', label=\"$S^* numerically$\")\nplt.legend(edgecolor='k')\nplt.xlabel('Time ($h$)')\nplt.ylabel('S cell/mL')\nplt.title(\"SV numerical integration\")\n</pre> import numpy as np import matplotlib.pyplot as plt from scipy import integrate  # Numerical time t0 = 0 # Initial time tf = 24 # Final time T = np.linspace(t0,tf) # time steps to report # Initial population size y0 = np.zeros(2) y0[0] = 1E4; # parameters pars={} pars[\"phi\"] = 6.7E-10 pars[\"m\"] = 1/24 pars[\"d\"] = 1/4 pars[\"b\"] = 0.95 pars[\"K\"] = 7.5E7 pars[\"beta\"] = 50  dy = integrate.odeint(SV_ode,y0,T,args=(pars,)) S = dy[:,0]  # Find the equilibrium value numerically:  Seq_num = S[-1] # plot plt.plot(T,S,'k', label=\"$S(t)$\") plt.scatter(T[-1],Seq_num,color='red', label=\"$S^* numerically$\") plt.legend(edgecolor='k') plt.xlabel('Time ($h$)') plt.ylabel('S cell/mL') plt.title(\"SV numerical integration\") Out[2]: <pre>Text(0.5, 1.0, 'SV numerical integration')</pre> <p>Analytically, we find that in absence of virus in the system $(V0 = 0), \\dot{V} = 0$ and the system remains disease-free. The SV system reduces to the logistic model with cell death, $\\dot{S} = bS(1- S/K) - dS$. Solving $\\dot{S} = 0$, we find that S approaches the equilibrium point $S^\u2217 = K(1-d/b)$</p> In\u00a0[4]: Copied! <pre>Seq_ana = pars[\"K\"]*(1-pars[\"d\"]/pars[\"b\"])\nprint(\"Seq = \", Seq_ana)\n# plot and compare\nplt.plot(T,S,'k', label=\"$S(t)$\")\nplt.scatter(T[-1],Seq_num,color='red', label=\"$S^* numerically$\")\nplt.plot(T,np.repeat(Seq_ana,len(T)),color='green', label=\"$S^* analytically$\")\nplt.legend(edgecolor='k')\nplt.xlabel('Time ($h$)')\nplt.ylabel('S cell/mL')\nplt.title(\"SV numerical integration\")\n</pre> Seq_ana = pars[\"K\"]*(1-pars[\"d\"]/pars[\"b\"]) print(\"Seq = \", Seq_ana) # plot and compare plt.plot(T,S,'k', label=\"$S(t)$\") plt.scatter(T[-1],Seq_num,color='red', label=\"$S^* numerically$\") plt.plot(T,np.repeat(Seq_ana,len(T)),color='green', label=\"$S^* analytically$\") plt.legend(edgecolor='k') plt.xlabel('Time ($h$)') plt.ylabel('S cell/mL') plt.title(\"SV numerical integration\") <pre>Seq =  55263157.89473685\n</pre> Out[4]: <pre>Text(0.5, 1.0, 'SV numerical integration')</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"day1_eco_evo_principles/python_exercises_day1/#python-exercises","title":"Python - Exercises\u00b6","text":""},{"location":"day1_eco_evo_principles/python_exercises_day1/#day-1-june-23-2025","title":"Day 1 (June 23, 2025)\u00b6","text":""},{"location":"day1_eco_evo_principles/python_exercises_day1/#goal-1-simulate-a-viral-invasion-sv-lytic-model","title":"Goal 1: Simulate a viral invasion - SV lytic model\u00b6","text":"<p>Consider the SV model for lytic infections with susceptible cells (S) and free viruses (V) given by, \\begin{align} \\dot{S} &amp;= bS (1- S/K) - \\phi SV - dS\\\\ \\dot{V} &amp;= \\beta\\phi SV - \\phi SV - mV \\end{align}</p> <p>use the following set of parameter values:</p> <ul> <li>$ \\phi = 6.7 \\times 10^{-10} \\ \\text{mL} \\ \\text{h}^{-1} $</li> <li>m = $$ 1/24 h^{\u22121} $$</li> <li>d =  $1/4 h^{\u22121}$</li> <li>b = $0.95 h^{\u22121}$</li> <li>K = 7.5107 cell $mL^{\u22121}$</li> <li>\u03b2 = 50 virus/cell</li> </ul>"},{"location":"day1_eco_evo_principles/python_notebook_day1/","title":"Python - Lectures","text":"<p>If you need installation help you can read the documentation here or ask one of the TAs.</p> <p>Once you have a lot of commands, it will get exhausting typing them again and again (especially when you make mistakes). Instead, you will want to use a \\script\". A script is a list of commands in a \u2002le that you can execute directly from the command window. To create a script go to the File menu and select New &gt; File. Now type in a few commands, such as:</p> In\u00a0[1]: Copied! <pre>#my_first_file.py\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Create some vectors\nx = np.arange(1,10,0.1)\ny1 = np.exp(0.5*x)\ny2 = np.exp(0.6*x)\n#plot the vectors\nplt.plot(x,y1,'k') #Use a black line\nplt.plot(x,y2,c=[0.5,0.5,0.5]) #Use a grey line\nplt.xlabel('x') #Label the axis\nplt.ylabel('y')\n#save the image to a file\nplt.savefig('my_first.pdf',bbox_inches='tight')\n</pre> #my_first_file.py import numpy as np import matplotlib.pyplot as plt # Create some vectors x = np.arange(1,10,0.1) y1 = np.exp(0.5*x) y2 = np.exp(0.6*x) #plot the vectors plt.plot(x,y1,'k') #Use a black line plt.plot(x,y2,c=[0.5,0.5,0.5]) #Use a grey line plt.xlabel('x') #Label the axis plt.ylabel('y') #save the image to a file plt.savefig('my_first.pdf',bbox_inches='tight') <p>The problem with this script is that changing the arguments in the exponential functions requires editing the script and then re-running the code. It would be more convenient to designate a variable change from the command window and have the code automatically update its output. The problem is that a script cannot return a variable or accept a variable as input. To do so requires a \"function\". Functions are program \u2002les that can be called from the Command window, can accept inputs, and return outputs. To start one, open a new\u2002file and type:</p> In\u00a0[3]: Copied! <pre>def logGrowth(N,t):\n    \"\"\"\n    function dNdt = logGrowth(N,t)\n    logGrowth gives the growth rate of a population of size N at time t\n    usage: dNdt = logGrowth(N,t)\n    \"\"\"\n    r = 0.5\n    K = 100\n    dNdt = r*N*(1-N/K)\n    return dNdt\n</pre> def logGrowth(N,t):     \"\"\"     function dNdt = logGrowth(N,t)     logGrowth gives the growth rate of a population of size N at time t     usage: dNdt = logGrowth(N,t)     \"\"\"     r = 0.5     K = 100     dNdt = r*N*(1-N/K)     return dNdt <p>Now the new function can be accessed just like one of Python's built-in functions, for example, type the following code into a new \u2002le named \\Lab1_Functions\". Note that to use code from another \u2002le, import the \u2002le</p> In\u00a0[6]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nvN = np.arange(0,110)\nplt.plot(vN,logGrowth(vN,0))\nplt.xlabel('N')\nplt.ylabel('dN/dt')\n</pre>  import numpy as np import matplotlib.pyplot as plt  vN = np.arange(0,110) plt.plot(vN,logGrowth(vN,0)) plt.xlabel('N') plt.ylabel('dN/dt') Out[6]: <pre>Text(0, 0.5, 'dN/dt')</pre> <p>This gives an upside down parabola, denoting that growth rate is positive between 0 and 100 and negative when N is greater than 100. Note that the argument t is not used in the logGrowth function. Not all inputs have to be used. We will update this function later to both accept and utilize all inputs.</p> <p>You may decide to use Python to numerically solve di\u2002erential equations, like the logistic growth equation, even when such solutions are not available analytically. But, in many cases, such solutions are not available analytically, and hence we must use such techniques to help build intuition. The most-used Python program which does the integration is called integrate.odeint from the scipy package. Here is a script that integrates the logGrowth function.</p> In\u00a0[7]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import integrate\n#Numerical solution of the logisitic equation\nt0 = 0 # Initial time\ntf = 50 # Final time\nN0 = 1 # Initial population size\nT = np.linspace(t0,tf) # time steps to report\nvNint = integrate.odeint(logGrowth,N0,T)\n# Actual solution\nr = 0.5\nK = 100\nvNact = (N0*np.exp(r*T))/(1+N0*(np.exp(r*T)-1)/K) # Actual solution\n# Plot results\nplt.plot(T,vNint) # Plot numerically integrated solution\nplt.scatter(T,vNact,color='red') # Plot actual solution\nplt.xlabel('Time')\nplt.ylabel('Population size')\nplt.title('Logisitic model')\n</pre> import numpy as np import matplotlib.pyplot as plt from scipy import integrate #Numerical solution of the logisitic equation t0 = 0 # Initial time tf = 50 # Final time N0 = 1 # Initial population size T = np.linspace(t0,tf) # time steps to report vNint = integrate.odeint(logGrowth,N0,T) # Actual solution r = 0.5 K = 100 vNact = (N0*np.exp(r*T))/(1+N0*(np.exp(r*T)-1)/K) # Actual solution # Plot results plt.plot(T,vNint) # Plot numerically integrated solution plt.scatter(T,vNact,color='red') # Plot actual solution plt.xlabel('Time') plt.ylabel('Population size') plt.title('Logisitic model') Out[7]: <pre>Text(0.5, 1.0, 'Logisitic model')</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"day1_eco_evo_principles/python_notebook_day1/#python-lectures","title":"Python - Lectures\u00b6","text":""},{"location":"day1_eco_evo_principles/python_notebook_day1/#day-1-june-23-2025","title":"Day 1 (June 23, 2025)\u00b6","text":""},{"location":"day1_eco_evo_principles/python_notebook_day1/#building-programs-from-scripts-and-functions","title":"Building \"Programs\" from \"Scripts\" and \"Functions\"\u00b6","text":""},{"location":"day1_eco_evo_principles/python_notebook_day1/#numerically-integrating-differential-equations","title":"Numerically Integrating Differential Equations\u00b6","text":""}]}